import { storage } from "../storage";
import type { InsertTimetableChange, InsertSubstitution, InsertAuditLog } from "@shared/schema";

interface AbsenceDetectionResult {
  teacherId: string;
  date: string;
  affectedClasses: Array<{
    timetableEntryId: string;
    className: string;
    subject: string;
    period: number;
    day: string;
    changeId?: string;
    substituteAssigned?: boolean;
    substituteTeacherId?: string;
  }>;
  totalChanges: number;
}

export class AbsenceDetectionService {
  /**
   * Automatically detect and handle teacher absence by creating timetable changes
   * and attempting to assign substitute teachers
   */
  static async handleTeacherAbsence(
    teacherId: string, 
    date: string, 
    reason: string,
    markedBy: string
  ): Promise<AbsenceDetectionResult> {
    console.log(`Processing automatic absence detection for teacher ${teacherId} on ${date}`);
    
    const result: AbsenceDetectionResult = {
      teacherId,
      date,
      affectedClasses: [],
      totalChanges: 0
    };

    try {
      // 1. Get teacher's scheduled classes for the absence date
      const teacherTimetable = await storage.getTimetableForTeacher(teacherId);
      const dayOfWeek = new Date(date).toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
      
      // Filter for the specific day
      const affectedEntries = teacherTimetable.filter(entry => 
        entry.day.toLowerCase() === dayOfWeek
      );

      console.log(`Found ${affectedEntries.length} scheduled periods for teacher on ${dayOfWeek}`);

      // 2. Process each affected timetable entry
      for (const entry of affectedEntries) {
        try {
          // Create timetable change record for absence
          const changeRecord = await storage.createTimetableChange({
            timetableEntryId: entry.id,
            changeType: "substitution",
            changeDate: date,
            originalTeacherId: teacherId,
            newTeacherId: null, // Will be updated if substitute is found
            reason: `Teacher absence: ${reason}`,
            changeSource: "auto_absence",
            isActive: true
          });

          console.log(`Created timetable change record ${changeRecord.id} for entry ${entry.id}`);

          // 3. Attempt to find and assign a substitute teacher
          let substituteAssigned = false;
          let substituteTeacherId: string | undefined;

          try {
            // Find available substitute teachers for this period
            const substitutes = await this.findAvailableSubstitutes(
              entry.id,
              teacherId,
              date,
              dayOfWeek,
              entry.period
            );

            if (substitutes.length > 0) {
              // Assign the first available substitute
              const substitute = substitutes[0];
              substituteTeacherId = substitute.id;

              // Update the timetable change record with substitute info
              await storage.updateTimetableChange(changeRecord.id, {
                newTeacherId: substitute.id,
                reason: `Teacher absence: ${reason}. Auto-assigned substitute: ${substitute.name}`
              });

              // Create substitution record
              await storage.createSubstitution({
                originalTeacherId: teacherId,
                substituteTeacherId: substitute.id,
                timetableEntryId: entry.id,
                date: new Date(date + 'T00:00:00Z'),
                reason: `Auto-assigned for teacher absence: ${reason}`,
                status: "auto_assigned",
                isAutoGenerated: true
              });

              substituteAssigned = true;
              console.log(`Assigned substitute ${substitute.name} for period ${entry.period}`);
            } else {
              // No substitute available - mark as needing manual assignment
              await storage.updateTimetableChange(changeRecord.id, {
                reason: `Teacher absence: ${reason}. No substitute available - requires manual assignment`
              });
              console.log(`No substitute available for period ${entry.period} - manual assignment required`);
            }
          } catch (substituteError) {
            console.error(`Error finding substitute for entry ${entry.id}:`, substituteError);
          }

          // 4. Add to result (note: entry from getTimetableForTeacher includes joined data)
          result.affectedClasses.push({
            timetableEntryId: entry.id,
            className: `${(entry as any).class?.grade || 'Unknown'}-${(entry as any).class?.section || 'Unknown'}`,
            subject: (entry as any).subject?.name || 'Unknown Subject',
            period: entry.period,
            day: entry.day,
            changeId: changeRecord.id,
            substituteAssigned,
            substituteTeacherId
          });

          result.totalChanges++;

        } catch (entryError) {
          console.error(`Error processing timetable entry ${entry.id}:`, entryError);
        }
      }

      // 5. Log the automatic detection activity
      try {
        await storage.createAuditLog({
          action: "auto_absence_detection",
          entityType: "teacher_attendance",
          entityId: teacherId,
          userId: markedBy,
          description: `Automatic absence detection: ${date}, ${reason}, ${result.affectedClasses.length} classes affected`,
          schoolId: (await storage.getTeacher(teacherId))?.schoolId || ""
        });
      } catch (auditError) {
        console.error("Error creating audit log for absence detection:", auditError);
      }

      console.log(`Absence detection completed: ${result.totalChanges} changes created, ${result.affectedClasses.filter(c => c.substituteAssigned).length} substitutes assigned`);

    } catch (error) {
      console.error("Error in automatic absence detection:", error);
      throw new Error(`Failed to process teacher absence: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }

    return result;
  }

  /**
   * Find available substitute teachers for a specific time slot
   */
  private static async findAvailableSubstitutes(
    timetableEntryId: string,
    originalTeacherId: string,
    date: string,
    dayOfWeek: string,
    period: number
  ): Promise<Array<{ id: string; name: string; subjectCompatibility: boolean }>> {
    try {
      // Get the timetable entry details
      const timetableEntries = await storage.getTimetableEntries();
      const targetEntry = timetableEntries.find(entry => entry.id === timetableEntryId);
      
      if (!targetEntry) {
        return [];
      }

      // Get all teachers from the same school (fetch class info separately)
      const classInfo = await storage.getClass(targetEntry.classId);
      if (!classInfo) return [];
      
      const allTeachers = await storage.getTeachers(classInfo.schoolId);
      
      // Filter out the absent teacher
      const availableTeachers = allTeachers.filter(teacher => teacher.id !== originalTeacherId);

      const substitutes = [];

      for (const teacher of availableTeachers) {
        // Check if teacher is not absent on the same date
        const isAbsent = await storage.isTeacherAbsent(teacher.id, date);
        if (isAbsent) {
          continue;
        }

        // Check if teacher has conflicting periods on the same day
        const teacherTimetable = await storage.getTimetableForTeacher(teacher.id);
        const hasConflict = teacherTimetable.some(entry => 
          entry.day.toLowerCase() === dayOfWeek.toLowerCase() && 
          entry.period === period
        );

        if (hasConflict) {
          continue;
        }

        // Check subject compatibility (can the teacher teach this subject)
        const subjectCompatibility = (teacher as any).subjects?.some((subject: any) => 
          subject.id === targetEntry.subjectId
        ) || false;

        substitutes.push({
          id: teacher.id,
          name: teacher.name,
          subjectCompatibility
        });
      }

      // Sort by subject compatibility first, then by name
      substitutes.sort((a, b) => {
        if (a.subjectCompatibility && !b.subjectCompatibility) return -1;
        if (!a.subjectCompatibility && b.subjectCompatibility) return 1;
        return a.name.localeCompare(b.name);
      });

      console.log(`Found ${substitutes.length} potential substitutes for ${dayOfWeek} period ${period}`);
      return substitutes;

    } catch (error) {
      console.error("Error finding available substitutes:", error);
      return [];
    }
  }

  /**
   * Check if a teacher becoming present again requires reverting automatic changes
   */
  static async handleTeacherReturn(
    teacherId: string,
    date: string,
    markedBy: string
  ): Promise<{ revertedChanges: number; message: string }> {
    console.log(`Processing teacher return for ${teacherId} on ${date}`);

    try {
      // Find all auto-generated changes for this teacher and date
      const allChanges = await storage.getTimetableChanges(
        (await storage.getTeacher(teacherId))?.schoolId || "",
        date
      );

      const autoChangesToRevert = allChanges.filter(change => 
        change.originalTeacherId === teacherId &&
        change.changeSource === "auto_absence" &&
        change.isActive &&
        !change.approvedBy // Only revert unapproved changes
      );

      let revertedCount = 0;

      for (const change of autoChangesToRevert) {
        // Deactivate the timetable change
        await storage.updateTimetableChange(change.id, {
          isActive: false,
          reason: `${change.reason} - Reverted: Teacher returned`
        });

        // If there was an auto-assigned substitution, remove it
        if (change.newTeacherId) {
          const substitutions = await storage.getSubstitutions();
          const relatedSubstitution = substitutions.find(sub => 
            sub.originalTeacherId === teacherId &&
            sub.timetableEntryId === change.timetableEntryId &&
            sub.date.toISOString().split('T')[0] === date &&
            sub.status === "auto_assigned"
          );

          if (relatedSubstitution) {
            await storage.deleteSubstitution(relatedSubstitution.id);
          }
        }

        revertedCount++;
      }

      // Log the return activity
      await storage.createAuditLog({
        action: "auto_teacher_return",
        entityType: "teacher_attendance",
        entityId: teacherId,
        userId: markedBy,
        description: `Teacher return: ${date}, ${revertedCount} changes reverted`,
        schoolId: (await storage.getTeacher(teacherId))?.schoolId || ""
      });

      const message = revertedCount > 0 
        ? `Teacher returned: ${revertedCount} automatic changes reverted`
        : "Teacher returned: No automatic changes to revert";

      console.log(message);

      return { revertedChanges: revertedCount, message };

    } catch (error) {
      console.error("Error handling teacher return:", error);
      throw new Error(`Failed to process teacher return: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}